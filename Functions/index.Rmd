---
title: "Functions"
author: "Introduction to R for Public Health Researchers"
output:
  ioslides_presentation:
    css: ../styles.css
    widescreen: yes
---

## Writing your own functions

So far we've seen many functions, like `c()`, `class()`, `filter()`, `dim()` ...

**Why create your own functions?**

- Cut down on repetitive code (easier to fix things!)
- Organize code into manageable chunks
- Avoid running code unintentionally
- Use names that make sense to you

## Writing your own functions

Here we will write a function that returns the second element of a vector:

```{r return2a, comment=""}
return2a = function(x) x[2]
```

When you run the line of code above, you make it ready to use (no output yet!). Let's test it!

```{r return2a2, comment=""}
return2a(x = c(1,4,5,76))
```

## Writing your own functions

Adding the curly brackets - `{}` - allows you to use functions spanning multiple lines:

```{r return2b, comment=""}
return2b = function(x) {
  x[2]
}
return2b(x = c(1,4,5,76))
```

## Writing your own functions

If we want something specific for the function's output, we use `return()`:

```{r return2c, comment=""}
return2c = function(x) {
  output = x[2]
  return(output)
}
return2c(x = c(1,4,5,76))
```

## Writing your own functions

**Review**: The syntax for a function is: 

```
functionName = function(inputs) {
 <function body>
return(value)
}
```

## Writing your own functions

Functions can take multiple inputs. Maybe you want users to select which element to extract:

```{r return_n, comment=""}
return_n = function(x, n) x[n]
return_n(x = c(1,4,5,76), n = 3)
```

## Writing your own functions

Functions can have "default" arguments. This lets us use the function without using an argument later.

```{r return_n2, comment=""}
return_n2 = function(x = c(1,2,3), n = 2) x[n]
return_n2()
```

## Writing a simple function

Let's write a function, `sqdif`, that:

1. takes two numbers `x` and `y` with default values of 2 and 3.
2. takes the difference
3. squares this difference
4. then returns the final value 

## Writing a simple function

```{r sqdif, comment=""}
sqdif <- function(x=2,y=3) (x-y)^2

sqdif()
sqdif(x=10,y=5)
sqdif(10,5)
```

## Writing your own functions

Try to write a function called `top()` that takes a `tibble`, and returns the first `n` rows and columns, with the default value of `n=5`.

## Writing your own functions

Try to write a function called `top()` that takes a `tibble`, and returns the first `n` rows and columns

```{r top, message=FALSE}
top = function(df, n=5) df[1:n, 1:n]
bike = jhur::read_bike()
```
```{r, comment=""}
top(bike) # Note that we are using the default value for n 
```

## Custom functions in `apply`

You can also "apply" functions easily with `sapply()`.

These functions take the form:

```
sapply(???, some_function) # No parentheses on the function
```

## Custom functions in `apply`

```{r sapply1, comment=""}
sapply(bike, class)
sapply(bike$length, log)
```



## Website

[Website](http://jhudatascience.org/intro_to_R_class/index.html)
