---
title: "Functions"
author: "Introduction to R for Public Health Researchers"
output:
  ioslides_presentation:
    css: ../styles.css
    widescreen: yes
---

```{r, echo = FALSE, message = FALSE}
library(dplyr)
library(jhur)
library(knitr)
opts_chunk$set(comment = "")
```

## Writing your own functions

So far we've seen many functions, like `c()`, `class()`, `filter()`, `dim()` ...

**Why create your own functions?**

- Cut down on repetitive code (easier to fix things!)
- Organize code into manageable chunks
- Avoid running code unintentionally
- Use names that make sense to you

## Writing your own functions

Here we will write a function that multiplies some number (x) by 2:

```{r comment=""}
times_2 <- function(x) x * 2
```

When you run the line of code above, you make it ready to use (no output yet!). Let's test it!

```{r comment=""}
times_2(x = 10)
```

## Writing your own functions: `{ }`

Adding the curly brackets - `{}` - allows you to use functions spanning multiple lines:

```{r comment=""}
times_2 <- function(x) {
  x * 2
}
times_2(x = 10)
```

## Writing your own functions: `return`

If we want something specific for the function's output, we use `return()`:

```{r comment=""}
times_2 <- function(x) {
  output <- x * 2
  return(output)
}
times_2(x = 10)
```

## Writing your own functions

**Review**: The syntax for a function is: 

```
functionName = function(inputs) {
 <function body>
return(value)
}
```

## Writing your own functions: multiple inputs

Functions can take multiple inputs.

```{r comment=""}
times_2_plus_y <- function(x, y) x * 2 + y
times_2_plus_y(x = 10, y = 3)
```

## Writing your own functions: defaults

Functions can have "default" arguments. This lets us use the function without using an argument later.

```{r comment=""}
times_2_plus_y <- function(x = 10, y = 3) x * 2 + y
times_2_plus_y()
```

## Writing another simple function

Let's write a function, `sqdif`, that:

1. takes two numbers `x` and `y` with default values of 2 and 3.
2. takes the difference
3. squares this difference
4. then returns the final value 

## Writing another simple function

```{r sqdif, comment=""}
sqdif <- function(x = 2, y = 3) (x - y) ^ 2

sqdif()
sqdif(x = 10, y = 5)
sqdif(10, 5)
```

## Functions for tibbles

We can use `filter(row_number()==n)` to extract a row of a tibble.

```{r message=FALSE}
bike <- read_bike()

get_row <- function(dat, row) dat %>% filter(row_number()==row)

get_row(dat = bike, row = 10)
```

## Functions for tibbles

`select(n)` will choose column `n`.

```{r message=FALSE}
get_index <- function(dat, row, col){
 dat %>% filter(row_number()==row) %>% select(col) 
}

get_index(dat = bike, row = 10, col = 8)
```

## Functions for tibbles

Inlcuding default values for arguments:

```{r message=FALSE}
get_top <- function(dat, row = 1, col = 1){
 dat %>% filter(row_number()==row) %>% select(col) 
}

get_top(dat = bike)
```

## Using your custom functions: `sapply()`

You can also "apply" functions easily with `sapply()`.

These functions take the form:

```
sapply(a vector or list, some_function) # No parentheses on the function!!
```

## Using your custom functions: `sapply()`

```{r sapply1, comment=""}
sapply(bike, class)
sapply(pull(bike, length), log)
```

## Using your custom functions: `sapply()`

```{r}
bike %>% 
  mutate(len_2_5 = sapply(pull(bike, length), times_2_plus_y))
```



## Website

[Website](http://jhudatascience.org/intro_to_R_class/index.html)
