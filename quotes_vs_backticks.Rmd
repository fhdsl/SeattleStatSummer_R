---
title: "Quotes vs backticks"
output: html_document
---

When do you use quotes, backticks, or nothing in R?

There are some inconsistencies across different functions, sometimes you just need to try them out. Always check that your work did what you expect!

In general these are the conventions for working with values:

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(kableExtra)
text_tbl <- data.frame(
    Type = c("character string", "character string ", "atypical", "atypical", "atypical", "atypical"),
  Example = c("Liver", "New York", "col 1", "col.1", "1", "1st col"),
  Features = c("word", "phrase", "has spaces and numbers", "has punctuation ", "just a number", "starts with number"),
 Use = c("use quotes - single or double", "use quotes - single or double", "use `backticks`", "use `backticks`", "use `backticks`", "use `backticks`")
)
kbl(text_tbl) %>%
  #kable_classic(full_width = F, html_font = "helvetica") %>%
  kable_paper(full_width = F, html_font = "helvetica", font_size = "18") %>%
  column_spec(1:4, bold = T, border_right = T, border_left = TRUE) %>%
  row_spec(0, align = "c") %>%
  row_spec(1:2,  background = "yellow") %>%
  row_spec(3:6, background = "lightgreen")
```

Column names are slightly different because we typically want to avoid spaces in general and character strings like words are expected and therefore the often don't require quotes. We will go over some of these situations.


## `tibble()` for naming variables

- we suggest that you avoid nonstandard **variable** names - if you do you do not need any quotes or backticks around the name within `tibble`


- backticks are typically for nonstandard **variable** names (aka column names):
  - those with spaces `name with space`
  - those with punctuation `name!`
  - those that are just numbers `12`
  - those that start with numbers `1name`
  
- single or double quotes are typically used for **character strings**  for the values within the data 

For example, in the `iris` data set:

```{r}
head(iris)
```

Sepal.Length is a column/variable name that would often need backticks, while the Species setosa is character string value for the variable Species, and it would need quotes.

Let's check out how some functions work with this.

In the `tibble()` function when specifying names we need to use backticks when we have spaces or punctuation or variable names that are just numeric characters (this also works with single quotes or double quotes, but backticks are more common practice). 

This is not required if we have a typical type of name without spaces or punctuation. However if we do use quotes on such a name is is not a problem either. 

```{r, include = FALSE}
library(tidyverse)
```

```{r}

# the preferred method

ex_data <- tibble(
  `Number!` = seq(from = 1, to = 5),
  `Var with space` = c("A", "B", "C", "D", "E"),
  `2022` = sample(seq(from = 1, to = 5), size = 5),
  `2021` = sample(seq(from = 1, to = 5), size = 5),
  typical = seq(from = 1, to = 5),
  `typical2` = seq(from = 1, to = 5)
)

ex_data

# this works

ex_data <- tibble(
  "Number!" = seq(from = 1, to = 5),
  "Var with space" = c("A", "B", "C", "D", "E"),
  "2022" = sample(seq(from = 1, to = 5), size = 5),
  "2021" = sample(seq(from = 1, to = 5), size = 5),
  typical = seq(from = 1, to = 5),
  "typical2" = seq(from = 1, to = 5)
)
ex_data
```

## `rename()`

same thing here...

```{r}
ex_data %>%
  rename(Number = `Number!`)

ex_data %>%
  rename(Number = "Number!")

# not necessary but not problematic to put new typical name in quotes
ex_data %>%
  rename("Number" = "Number!")
```

## Here is another example...

```{r}
# This works because Sepal.Length already exists as a column name. However `new name!` needs backticks because it doesn't exist yet and R needs to know what it is (not a not equal to conditional for example), as R could interpret it differently.

iris %>%
  rename(`new name!` = Sepal.Length) %>%
  head()
```

## `summarize()`

Only backticks will work here. Otherwise, the variable gets interpreted as a character string if we use quotes.

```{r}
ex_data %>%
  summarize(mean = mean(`2022`))

# will not work
# ex_data %>%
#   summarize(mean = mean("2022"))

# will not work
# ex_data %>%
#   summarize(mean = mean("Number!"))
```

## `mutate()`

Only these work... 

```{r}
ex_data %>% mutate(`Number!` = `Number!` + 2)
ex_data %>% mutate("Number!" = `Number!` + 2)

ex_data %>% mutate(Typical = `Number!` + 2)
```

## `stringr` functions

When working with strings we need to use quotes.

```{r}
x <- c("cat", "dog", "mouse")
# this will not work:
# x <- c(`cat`, `dog`, `mouse`)
```

When looking for patterns we need to use quotes because we are using it as a character string and quotes designate this. Backticks will not work.

```{r}
x <- c("cat", "dog", "mouse")
# this will not work:
# x <- c(`cat`, `dog`, `mouse`)
str_detect(pattern = "t", string = x)
# this will not work:
# str_detect(pattern = `t`, string = x)
```

## `pivot_longer` and `pivot_wider` are a bit different

For column names that do not exist yet, you need quotes (single or double). Backticks will not work.

```{r, eval = FALSE}
library(jhur)
wide_circ <- read_circulator()

long_circ <- wide_circ %>%
  pivot_longer(
    cols = contains(c("boarding")),
    names_to = "Route",
    values_to = "Boardings"
  )

long_circ <- wide_circ %>%
  pivot_longer(
    cols = contains(c("boarding")),
    names_to = "Route",
    values_to = "Boardings"
  )
```

These will not work:
```{r, eval = FALSE}
long_circ <- wide_circ %>%
  pivot_longer(
    cols = contains(c("boarding")),
    names_to = `Route`,
    values_to = `Boardings`
  )

long_circ <- wide_circ %>%
  pivot_longer(
    cols = contains(c("boarding")),
    names_to = Route,
    values_to = Boardings
  )
``` 

## With the `filter()` function it is best to avoid using quotes for columnames!

Even though this is an atypical column name, this will not work like you would expect. 

Here we see values less than 5 for `Sepal.Length`.

```{r}
filter(iris,"Sepal.Length" > 5) %>% head()
```

Instead stick to just using the column name as it is - filter only works on columns that already exists, so it knows what to look for. 

This works!

```{r}
filter(iris, Sepal.Length > 5) %>% head()
```

